from tkinter import Canvas, VERTICAL, HORIZONTAL
from datetime import date, datetime, timedelta


class Partition(Canvas):
    """
        Provide methods to displays a partition
    """

    def __init__(self, root, v_min, v_max, orient=HORIZONTAL, **cfg):
        super().__init__(root, **cfg)
        self.v_min, self.v_max = v_min, v_max
        if orient not in (VERTICAL, HORIZONTAL):
            raise ValueError(f"orient should be in [{HORIZONTAL}, {VERTICAL}]")

        self.orient = orient
        self.items = {}
        self.bind("<Configure>", self.on_configure)

    def on_configure(self, _):
        for uid, coords in self.items.items():
            bbox = self._bbox(*coords)
            self.coords(uid, *map(int, bbox))

    def _calc(self, value, total):
        return (total * float(value - self.v_min)) / float(self.v_max - self.v_min)

    def _span(self, v_min, v_max):
        total = {
            VERTICAL: self.winfo_height(),
            HORIZONTAL: self.winfo_width()
        }[self.orient]
        return self._calc(v_min, total), self._calc(v_max, total)

    def _parse_value(self, value):
        if value <= self.v_min:
            return self.v_min
        elif value >= self.v_max:
            return self.v_max
        else:
            return value

    def _bbox(self, v_min, v_max):
        v_min = self._parse_value(v_min)
        v_max = self._parse_value(v_max)
        span = self._span(v_min, v_max)

        if self.orient == VERTICAL:
            xi, xf = 0, self.winfo_width()
            yi, yf = span
        elif self.orient == HORIZONTAL:
            xi, xf = span
            yi, yf = 0, self.winfo_height()
        else:
            raise Exception
        bbox = tuple(map(int, (xi, yi, xf, yf)))
        print(bbox)
        return bbox

    def set_item(self, v_min, v_max, **config):
        bbox = self._bbox(v_min, v_max)
        uid = self.create_rectangle(*bbox, **config)
        self.items[uid] = (v_min, v_max)

    def upd_item(self, uid, v_min=None, v_max=None, **config):
        item = self.items[uid]
        if v_min is not None or v_max is not None:
            if v_min is None:
                v_min = item[v_min]
            if v_max is None:
                v_max = item[v_max]
            self.items[uid] = (v_min, v_max)
            bbox = self._bbox(v_min, v_max)
            self.coords(*bbox)

        if config:
            self.itemconfigure(uid, **config)


class DateTimePartition(Partition):
    v_min: datetime
    v_max: datetime

    def __init__(self, root, v_min, v_max=None, **cfg):
        if isinstance(v_min, date) and v_max is None:
            v_min = datetime(year=v_min.year, month=v_min.month, day=v_min.day)
            v_max = v_min + timedelta(days=1)

        assert isinstance(v_min, datetime)
        assert isinstance(v_max, datetime)

        super().__init__(root, v_min, v_max, **cfg)

    def _parse_value(self, value):
        if type(value) is date:
            value = datetime(year=value.year, month=value.month, day=value.day)
        return super()._parse_value(value)

    def _calc(self, value, total):
        return (total * (value - self.v_min).total_seconds()) / (self.v_max - self.v_min).total_seconds()
